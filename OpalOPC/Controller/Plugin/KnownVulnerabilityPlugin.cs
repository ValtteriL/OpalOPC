using System.Text.Json;
using Microsoft.Extensions.Logging;
using Model;
using Opc.Ua;
using Opc.Ua.Client;
using Util;

namespace Plugin
{
    public class KnownVulnerabilityPlugin(ILogger logger, IKnownVulnerabilityApiRequestUtil knownVulnerabilityApiRequestUtil) : MultipleIssuesPostAuthPlugin(logger, s_pluginId, s_category, s_issueTitle, s_severity)
    {
        // check known vulnerabilities based on build info
        private static readonly PluginId s_pluginId = PluginId.KnownVulnerability;
        private static readonly string s_category = PluginCategories.Multiple;
        private static readonly string s_issueTitle = "ServerStatus";
        private static readonly double s_severity = 0.0; // this varies between issues

        public override async Task<List<Issue>> Run(IList<ISession> sessions)
        {
            ISession firstSession = sessions.First();
            _logger.LogTrace("{Message}", $"Checking {firstSession.Endpoint.EndpointUrl} for known vulnerabilities");
            List<Issue> issues = [];

            // try checking ServerStatus with each session until success
            BuildInfo? buildInfo = TryGetBuildInfo(sessions);

            if (buildInfo == null)
            {
                _logger.LogTrace("{Message}", "BuildInfo is null");
                return issues;
            }

            StrictBuildInfo strictBuildInfo = new(buildInfo);

            CVEResult? cveResult = await FindCVEsForBuildInfo(strictBuildInfo);
            if (cveResult == null)
            {
                return issues;
            }

            _logger.LogTrace("{Message}", $"Found {cveResult.vulnerabilities.Count} vulnerabilities for {firstSession.Endpoint.EndpointUrl}");

            // create issues for each CVE
            foreach (Vulnerability vulnerability in cveResult.vulnerabilities)
            {
                issues.Add(CreateIssue(vulnerability));
            }

            return issues;
        }

        private BuildInfo? TryGetBuildInfo(IList<ISession> sessions)
        {
            foreach (ISession session in sessions)
            {
                try
                {
                    ServerStatusDataType? serverStatusDataType = (ServerStatusDataType)session.ReadValue(Util.WellKnownNodes.Server_ServerStatus, typeof(ServerStatusDataType));
                    return serverStatusDataType?.BuildInfo;
                }
                catch
                {
                    _logger.LogTrace("{Message}", "Failed to read ServerStatus");
                }
            }
            return null;
        }

        private async Task<CVEResult?> FindCVEsForBuildInfo(StrictBuildInfo buildInfo)
        {
            _logger.LogTrace("{Message}", $"Downloading vulnerability data");

            try
            {
                HttpResponseMessage response = await knownVulnerabilityApiRequestUtil.PostAsJsonAsync(buildInfo);

                if (response.IsSuccessStatusCode)
                {
                    string responseString = await response.Content.ReadAsStringAsync();
                    return JsonSerializer.Deserialize<CVEResult>(responseString);
                }

                _logger.LogError("{Message}", $"Failed to download vulnerability data: {response.ReasonPhrase}");
                return null;
            }
            catch (HttpRequestException e)
            {
                _logger.LogError("{Message}", $"Failed to download vulnerability data: {e.Message}");
                return null;
            }
        }

        private static Issue CreateIssue(Vulnerability vulnerability)
        {
            string issueDescription = $"{vulnerability.cve.id}";
            double severity = 0;

            // set severity based on CVSS score
            // take the first base score available in cvssdata in the following order: v3.1, v3.0, v2
            Metrics? metrics = vulnerability.cve.metrics;

            double? v31BaseScore = metrics?.cvssMetricV31?.First()?.cvssData?.baseScore;
            double? v30BaseScore = metrics?.cvssMetricV30?.First()?.cvssData?.baseScore;
            double? v2BaseScore = metrics?.cvssMetricV2?.First()?.cvssData?.baseScore;

            if (v31BaseScore != null)
            {
                severity = v31BaseScore.Value;
            }
            else if (v30BaseScore != null)
            {
                severity = v30BaseScore.Value;
            }
            else if (v2BaseScore != null)
            {
                severity = v2BaseScore.Value;
            }

            return new Issue(s_pluginId, issueDescription, severity);
        }

    }
}
