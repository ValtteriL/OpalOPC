using System.Text.Json;
using Microsoft.Extensions.Logging;
using Model;
using Opc.Ua;
using Opc.Ua.Client;
using Util;

namespace Plugin
{
    public class KnownVulnerabilityPlugin(ILogger logger, IKnownVulnerabilityApiRequestUtil knownVulnerabilityApiRequestUtil) : MultipleIssuesPostAuthPlugin(logger, s_pluginId, s_category, s_issueTitle, s_severity)
    {
        // check known vulnerabilities based on build info
        private static readonly PluginId s_pluginId = PluginId.KnownVulnerability;
        private static readonly string s_category = PluginCategories.Multiple;
        private static readonly string s_issueTitle = "ServerStatus";
        private static readonly double s_severity = 0.0; // this varies between issues

        public override async Task<List<Issue>> Run(ISession session)
        {
            _logger.LogTrace("{Message}", $"Checking {session.Endpoint.EndpointUrl} for known vulnerabilities");
            List<Issue> issues = [];

            // check ServerStatus
            ServerStatusDataType? serverStatusDataType = (ServerStatusDataType)session.ReadValue(Util.WellKnownNodes.Server_ServerStatus, typeof(ServerStatusDataType));

            if (serverStatusDataType == null)
            {
                _logger.LogTrace("{Message}", "ServerStatus is null");
                return issues;
            }

            BuildInfo buildInfo = serverStatusDataType.BuildInfo;

            // send telemetry data
            TelemetryUtil.TrackEvent("KnownVulnerabilityAPI", GetBuildInfoProperties(buildInfo));

            CVEResult? cveResult = await FindCVEsForBuildInfo(buildInfo);
            if (cveResult == null)
            {
                return issues;
            }

            _logger.LogTrace("{Message}", $"Found {cveResult.vulnerabilities.Count} vulnerabilities for {session.Endpoint.EndpointUrl}");

            // create issues for each CVE
            foreach (Vulnerability vulnerability in cveResult.vulnerabilities)
            {
                issues.Add(CreateIssue(vulnerability));
            }

            return issues;
        }

        private async Task<CVEResult?> FindCVEsForBuildInfo(BuildInfo buildInfo)
        {
            _logger.LogTrace("{Message}", $"Downloading vulnerability data");

            try
            {
                HttpResponseMessage response = await knownVulnerabilityApiRequestUtil.PostAsJsonAsync(buildInfo);

                if (response.IsSuccessStatusCode)
                {
                    string responseString = await response.Content.ReadAsStringAsync();
                    return JsonSerializer.Deserialize<CVEResult>(responseString);
                }

                TelemetryUtil.TrackEvent("KnownVulnerabilityAPIError", GetHttpResponseMessageProperties(response));
                _logger.LogError("{Message}", $"Failed to download vulnerability data: {response.ReasonPhrase}");
                return null;
            }
            catch (HttpRequestException e)
            {
                _logger.LogError("{Message}", $"Failed to download vulnerability data: {e.Message}");
                TelemetryUtil.TrackException(e);
                return null;
            }
        }

        private static Issue CreateIssue(Vulnerability vulnerability)
        {
            string issueDescription = $"{vulnerability.cve.id}";
            double severity = 0;

            // set severity based on CVSS score
            // take the first base score available in cvssdata in the following order: v3.1, v3.0, v2
            Metrics? metrics = vulnerability.cve.metrics;

            double? v31BaseScore = metrics?.cvssMetricV31?.First()?.cvssData?.baseScore;
            double? v30BaseScore = metrics?.cvssMetricV30?.First()?.cvssData?.baseScore;
            double? v2BaseScore = metrics?.cvssMetricV2?.First()?.cvssData?.baseScore;

            if (v31BaseScore != null)
            {
                severity = v31BaseScore.Value;
            }
            else if (v30BaseScore != null)
            {
                severity = v30BaseScore.Value;
            }
            else if (v2BaseScore != null)
            {
                severity = v2BaseScore.Value;
            }

            return new Issue((int)s_pluginId, issueDescription, severity);
        }

        private static Dictionary<string, string> GetBuildInfoProperties(BuildInfo buildInfo)
        {
            return new()
            {
                { "ProductName", buildInfo.ProductName },
                { "ManufacturerName", buildInfo.ManufacturerName },
                { "SoftwareVersion", buildInfo.SoftwareVersion },
                { "BuildNumber", buildInfo.BuildNumber },
                { "ProductUri", buildInfo.ProductUri },
                { "BuildDate", buildInfo.BuildDate.ToShortDateString() },
            };
        }

        private static Dictionary<string, string> GetHttpResponseMessageProperties(HttpResponseMessage response)
        {
            return new()
            {
                { "StatusCode", response.StatusCode.ToString() },
                { "ReasonPhrase", response.ReasonPhrase ?? "" },
            };
        }

    }
}
