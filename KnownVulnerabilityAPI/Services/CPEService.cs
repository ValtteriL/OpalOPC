using System.Collections;
using System.Text.Json;
using KnownVulnerabilityAPI.Models;
using Microsoft.Data.Sqlite;

namespace KnownVulnerabilityAPI.Services
{
    public interface ICPEService
    {
        public Task<string> FindCPE(StrictBuildInfo strictBuildInfo);
    }
    public class CPEService : ICPEService
    {
        private readonly string _dbonnectionString;
        private const string CpeQuery = @"
            SELECT cpe
            FROM cpedict
            WHERE body MATCH $query
            ORDER BY rank
            LIMIT 1
        ";
        private readonly ILogger<CPEService> _logger;

        // ignore values in JSON that don't map to properties in the class
        private readonly JsonSerializerOptions _jsonSerializerOptions = new() { UnmappedMemberHandling = System.Text.Json.Serialization.JsonUnmappedMemberHandling.Skip };

        public CPEService(ILogger<CPEService> logger)
        {
            _logger = logger;
            _dbonnectionString = new SqliteConnectionStringBuilder()
            {
                Mode = SqliteOpenMode.ReadOnly,
                DataSource = $"{Directory.GetCurrentDirectory()}/database/db.sqlite3",
                Cache = SqliteCacheMode.Shared,
            }.ToString();
        }

        public async Task<string> FindCPE(StrictBuildInfo strictBuildInfo)
        {
            string? cpe;

            // get cves from database
            using (var connection = new SqliteConnection(_dbonnectionString))
            {
                await connection.OpenAsync();
                string[] tokenizedVendorName = NameFormatter.FormatName(GetVersionString(strictBuildInfo));

                // reverse the order of the tokenized vendor name
                // to search for the most specific name first
                tokenizedVendorName = tokenizedVendorName.Reverse().ToArray();

                Stack nameStack = new(tokenizedVendorName);

                // pop from stack until it's empty or we get results
                while (nameStack.Count > 0)
                {

                    string query = string.Join(" ", nameStack.ToArray());

                    cpe = await QueryForCPE(connection, query);

                    if (cpe != null)
                    {
                        return cpe;
                    }

                    nameStack.Pop();
                }

            }

            throw new ProductNotFoundException();
        }

        private async Task<string?> QueryForCPE(SqliteConnection connection, string query)
        {
            _logger.LogInformation("{msg}", $"Querying with: '{query}'");

            SqliteCommand command = connection.CreateCommand();
            command.CommandText = CpeQuery;
            command.Parameters.AddWithValue("$query", query);

            using (SqliteDataReader reader = await command.ExecuteReaderAsync())
            {
                if (await reader.ReadAsync())
                {
                    string cpeString = reader.GetString(0);
                    _logger.LogInformation("{msg}", $"Query '{query}' returned CPE {cpeString}");
                    return cpeString;
                }
            }

            _logger.LogInformation("{msg}", $"Query '{query}' returned returned no results");

            return null;
        }

        private static string GetVersionString(StrictBuildInfo strictBuildInfo)
        {
            return $"{strictBuildInfo.ProductName} {strictBuildInfo.SoftwareVersion} {strictBuildInfo.Manufacturer}";
        }
    }
}
