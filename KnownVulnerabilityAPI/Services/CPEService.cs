using System.Collections;
using KnownVulnerabilityAPI.Models;

namespace KnownVulnerabilityAPI.Services
{
    public interface ICPEService
    {
        Task<string> constructCPEName(StrictBuildInfo buildInfo);
    }
    public class CPEService(INVDAPIService nvdAPI, INameFormatterService nameFormatter, ILogger<CPEService> logger, ICacheService cacheService) : ICPEService
    {
        readonly string _version = "2.3";
        readonly string _part = "a";
        private readonly SemaphoreSlim _semaphore = new(1);

        public async Task<string> constructCPEName(StrictBuildInfo buildInfo)
        {
            await _semaphore.WaitAsync();
            string vendor = await findVendorName(buildInfo.Manufacturer);
            string product = await findProductName(buildInfo.ProductName, vendor);
            _semaphore.Release();
            return $"cpe:{_version}:{_part}:{vendor}:{product}:{buildInfo.SoftwareVersion}:*:*:*:*:*:*:*";
        }

        private async Task<string> findVendorName(string manufacturer)
        {
            string normalizedName = nameFormatter.FormatName(manufacturer);

            // split the normalizedName by spaces, and create stack of it
            Stack nameStack = new(normalizedName.Split(" "));

            // pop from stack until it's empty
            while (nameStack.Count > 0)
            {

                string query = string.Join(" ", nameStack.ToArray());

                CPEResult cpeResult = await CPEQuery(query);

                if (cpeResult.totalResults > 0)
                {
                    string cpeName = cpeResult.products[0].cpe.cpeName;
                    string vendor = cpeName.Split(':')[3];
                    return vendor;
                }

                nameStack.Pop();
            }

            throw new VendorNotFoundException("Failed to find vendor name");
        }

        private async Task<string> findProductName(string productName, string vendor)
        {
            string normalizedProductName = nameFormatter.FormatName(productName);

            // split the normalizedName by spaces, and create stack of it
            Stack nameStack = new(normalizedProductName.Split(" "));

            // pop from stack until it's empty
            while (nameStack.Count > 0)
            {
                string subquery = string.Join(" ", nameStack.ToArray());
                string query = $"{vendor} {subquery}";

                CPEResult cpeResult = await CPEQuery(query);

                if (cpeResult.totalResults > 0)
                {
                    string cpeName = cpeResult.products[0].cpe.cpeName;
                    string product = cpeName.Split(':')[4];
                    return product;
                }

                nameStack.Pop();
            }

            throw new ProductNotFoundException("Failed to find product name");
        }

        private async Task<CPEResult> CPEQuery(string query)
        {
            // first check cache
            CPEResult? cachedResult = cacheService.TryGetCPE(query);
            CPEResult cpeResult;
            if (cachedResult != null)
            {
                logger.LogInformation("{msg}", $"Using cached value for CPE query {query}");
                cpeResult = cachedResult;
            }
            else
            {
                // not found in cache, query NVD API
                logger.LogInformation("{msg}", $"Querying CPE for {query}");
                cpeResult = await nvdAPI.QueryCPE(query) ?? throw new Exception("Failed to parse CPE JSON");

                // cache the result
                cacheService.cacheCPE(query, cpeResult);
            }
            return cpeResult;
        }

    }
}
