using System.Collections;
using System.Text.Json;
using KnownVulnerabilityAPI.Models;
using Microsoft.Data.Sqlite;

namespace KnownVulnerabilityAPI.Services
{
    public interface ILocalDatabaseService
    {
        public Task<CVEResult> FindCPEandCVEs(StrictBuildInfo strictBuildInfo);
    }
    public class LocalDatabaseService : ILocalDatabaseService
    {
        private readonly string _dbonnectionString;
        private const string CpeQuery = @"
            WITH BestCpeMatch AS (
                SELECT cpe
                FROM cpedict
                WHERE body MATCH $query
                ORDER BY rank
                LIMIT 1
            )
            SELECT cve.file
            FROM cve
            JOIN cpe_cves ON cve.id = cpe_cves.cve_id
            JOIN cpe ON cpe_cves.cpe_id = cpe.id
            JOIN BestCpeMatch ON cpe.cpe = BestCpeMatch.cpe
        ";
        private readonly ILogger<LocalDatabaseService> _logger;

        // ignore values in JSON that don't map to properties in the class
        private readonly JsonSerializerOptions _jsonSerializerOptions = new() { UnmappedMemberHandling = System.Text.Json.Serialization.JsonUnmappedMemberHandling.Skip };

        public LocalDatabaseService(ILogger<LocalDatabaseService> logger)
        {
            _logger = logger;
            _dbonnectionString = new SqliteConnectionStringBuilder()
            {
                Mode = SqliteOpenMode.ReadOnly,
                DataSource = $"{Directory.GetCurrentDirectory()}/database/db.sqlite3",
                Cache = SqliteCacheMode.Shared,
            }.ToString();
        }

        public async Task<CVEResult> FindCPEandCVEs(StrictBuildInfo strictBuildInfo)
        {
            List<Cve> cves = [];

            // get cves from database
            using (var connection = new SqliteConnection(_dbonnectionString))
            {
                await connection.OpenAsync();
                string[] tokenizedVendorName = NameFormatter.FormatName(GetVersionString(strictBuildInfo));

                Stack nameStack = new(tokenizedVendorName);

                // pop from stack until it's empty or we get results
                while (nameStack.Count > 0)
                {

                    string query = string.Join(" ", nameStack.ToArray());

                    cves = await QueryForCves(connection, query);

                    if (cves.Count > 0)
                    {
                        break;
                    }

                    nameStack.Pop();
                }

            }

            return BuildCVEResult(cves);
        }

        private static CVEResult BuildCVEResult(List<Cve> cves)
        {
            // static values taken from here: https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:*:*
            return new CVEResult
            {
                startIndex = 0,
                version = "2.0",
                totalResults = cves.Count,
                resultsPerPage = cves.Count,
                format = "NVD_CVE",
                timestamp = DateTime.Now,
                vulnerabilities = cves.Select(cve => new Vulnerability { cve = cve }).ToList()
            };
        }

        private async Task<List<Cve>> QueryForCves(SqliteConnection connection, string query)
        {
            _logger.LogInformation("{msg}", $"Querying with: '{query}'");
            List<Cve> cves = [];

            SqliteCommand command = connection.CreateCommand();
            command.CommandText = CpeQuery;
            command.Parameters.AddWithValue("$query", query);

            using (SqliteDataReader reader = await command.ExecuteReaderAsync())
            {
                while (await reader.ReadAsync())
                {
                    string jsonString = reader.GetString(0); // data types: https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/types
                    Cve? cve = JsonSerializer.Deserialize<Cve>(jsonString, _jsonSerializerOptions);
                    cves.Add(cve!);
                }
            }

            _logger.LogInformation("{msg}", $"Query '{query}' returned {cves.Count} results");

            return cves;
        }

        private static string GetVersionString(StrictBuildInfo strictBuildInfo)
        {
            return $"{strictBuildInfo.ProductName} {strictBuildInfo.SoftwareVersion} {strictBuildInfo.Manufacturer}";
        }
    }
}
