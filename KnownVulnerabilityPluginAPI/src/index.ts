export interface Env {

}

type BuildInfo = {
		productUri: string;
		manufacturerName: string;
		productName: string;
		softwareVersion: string;
		buildNumber: string;
		buildDate: Date;
};

type CPEResult = {
		resultsPerPage: number,
		startIndex: number,
		totalResults: number,
		format: string,
		version: string,
		timestamp: string,
		products: [
				{
						cpe: {
								deprecated: boolean,
								cpeName: string,
								cpeNameId: string,
								lastModified: string,
								created: string,
								titles: [
										{
												title: string,
												lang: string,
										}
								],
						},
						refs: [
								{
										ref: string,
										type: string,
								}
						],
						deprecatedBy: [
								{
										cpeName: string,
										cpeNameId: string,
								}
						],
						deprecates: [
								{
										cpeName: string,
										cpeNameId: string,
								}
						],
				},
		],
};

export interface Env {
		API_KEY: string;
}

export default {
		async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {

				/**
				 * Convert a string to camel case
				 * @param str
				 * @returns
				 */
				function camelPad(str: string) {
						return str
								// remove all non-word characters
								.replace(/\W/g, '')
								// Look for long acronyms and filter out the last letter
								.replace(/([A-Z]+)([A-Z][a-z])/g, ' $1 $2')
								// Look for lower-case letters followed by upper-case letters
								.replace(/([a-z\d])([A-Z])/g, '$1 $2')
								// Look for lower-case letters followed by numbers
								.replace(/([a-zA-Z])(\d)/g, '$1 $2')
								.replace(/^./, function (str) { return str.toUpperCase(); })
								// Remove any white space left around the word
								.trim();
				}

				/**
				 * Given a manufacturer name in buildinfo, find the CPE vendor name
				 * @param manufacturerName
				 * @returns
				 */
				function findVendorName(manufacturerName: string): string {
						const padded = camelPad(manufacturerName);


						// split the padded string into words and print the list with one word less each time
						// the words should be removed from the end of the list
						// keep trying until we find a match or run out of words
						// if no match, return original string
						const splitPadded = padded.split(" ");
						for (let i = 0; i < splitPadded.length; i++) {
								const query = encodeURIComponent(splitPadded.slice(0, splitPadded.length - i).join(" "));
								const uri = `https://services.nvd.nist.gov/rest/json/cpes/2.0?keywordSearch=${query}`;

								// if result contains products, take cpeName of first and extract vendor
								// TODO - remember caching
								// IF
								fetch(uri, init).then((response) => {
										const cveResponse: CPEResult = JSON.parse(await response.json());
										if (cveResponse.totalResults > 0) {
												const cpeName = cveResponse.products[0].cpe.cpeName;
												const vendor = cpeName.split(":")[3];
										return vendor;
										}
								});

						}


						// if no match, throw error
						throw new Error(`No match found for manufacturer name: ${manufacturerName}`);
				}

				/**
				 * Given a product name in buildinfo and correct CPE vendor, find the CPE product name
				 * @param productName
				 * @param vendor
				 * @returns
				 */
				function findProductName(productName: string, vendor: string): string {

						const padded = camelPad(productName);

						// split the padded string into words and print the list with one word less each time
						// the words should be removed from the end of the list
						// keep trying until we find a match or run out of words
						// if no match, return original string
						const splitPadded = padded.split(" ");
						for (let i = 0; i < splitPadded.length; i++) {
								const query = encodeURIComponent(`${vendor} ${splitPadded.slice(0, splitPadded.length - i).join(" ")}`);
								const uri = `https://services.nvd.nist.gov/rest/json/cpes/2.0?keywordSearch=${query}`;

								// if result contains products, take cpeName of first and extract product name
								// TODO - remember caching
								// IF
								fetch(uri, init).then((response) => {
										const cveResponse: CPEResult = JSON.parse(await response.json());
										if (cveResponse.totalResults > 0) {
												const cpeName = cveResponse.products[0].cpe.cpeName;
												const product = cpeName.split(":")[4];
												return product;
										}
								});

						}

						// if no match, throw error
						throw new Error(`No match found for product name: ${productName}`);
				}

				// When filtering by cpeName the part, vendor, product, and version components
				// are REQUIRED to contain values other than "*".
				function constructCpeName(buildInfo: BuildInfo): string {

						const cpe_version = "2.3";
						const part = "a"; // application
						const vendor = findVendorName(buildInfo.manufacturerName);
						const product = findProductName(buildInfo.productName, vendor);
						const version = buildInfo.softwareVersion;

						return `cpe:${cpe_version}:${part}:${vendor}:${product}:${version}:*:*:*:*:*:*:*`;
				}

				// parse the build info from the request body
				const buildInfo: BuildInfo = JSON.parse(await request.json());

				// construct the CPE name
				const cpeMatchString = constructCpeName(buildInfo);

				// construct the URI for the NVD API
				const uri = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${cpeMatchString}`;
				const init = {
						headers: {
								"content-type": "application/json;charset=UTF-8",
								"apiKey": env.API_KEY,
						},
				};

				// fetch the CVE data for CPE
				const response = await fetch(uri, init); // TODO: cache the response for 24h
				const results = JSON.stringify(await response.json());

				// return the 
				return new Response(results, init);

		},
};
