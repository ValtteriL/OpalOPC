import { CPEResult, getCPEDetails } from "./cpe-api-util";
import { BuildInfo, Env } from "./index";

/**
				 * Convert a string to camel case
				 * @param str
				 * @returns
				 */
function camelPad(str: string) {
		return str
				// remove all non-word characters
				.replace(/\W/g, '')
				// Look for long acronyms and filter out the last letter
				.replace(/([A-Z]+)([A-Z][a-z])/g, ' $1 $2')
				// Look for lower-case letters followed by upper-case letters
				.replace(/([a-z\d])([A-Z])/g, '$1 $2')
				// Look for lower-case letters followed by numbers
				.replace(/([a-zA-Z])(\d)/g, '$1 $2')
				.replace(/^./, function (str) { return str.toUpperCase(); })
				// Remove any white space left around the word
				.trim();
}

/**
 * Given a manufacturer name in buildinfo, find the CPE vendor name
 * @param manufacturerName
 * @returns
 */
function findVendorName(manufacturerName: string, env: Env): string {
		const padded = camelPad(manufacturerName);


		// split the padded string into words and print the list with one word less each time
		// the words should be removed from the end of the list
		// keep trying until we find a match or run out of words
		// if no match, return original string
		const splitPadded = padded.split(" ");
		for (let i = 0; i < splitPadded.length; i++) {
				const query = encodeURIComponent(splitPadded.slice(0, splitPadded.length - i).join(" "));

				// if result contains products, take cpeName of first and extract vendor
				// IF
				getCPEDetails(query, env).then((cveResponse: CPEResult) => {
						if (cveResponse.totalResults > 0) {
								const cpeName = cveResponse.products[0].cpe.cpeName;
								const vendor = cpeName.split(":")[3];
								return vendor;
						}
				})
		}


		// if no match, throw error
		throw new Error(`No match found for manufacturer name: ${manufacturerName}`);
}

/**
 * Given a product name in buildinfo and correct CPE vendor, find the CPE product name
 * @param productName
 * @param vendor
 * @returns
 */
function findProductName(productName: string, vendor: string, env: Env): string {

		const padded = camelPad(productName);

		// split the padded string into words and print the list with one word less each time
		// the words should be removed from the end of the list
		// keep trying until we find a match or run out of words
		// if no match, return original string
		const splitPadded = padded.split(" ");
		for (let i = 0; i < splitPadded.length; i++) {
				const query = encodeURIComponent(`${vendor} ${splitPadded.slice(0, splitPadded.length - i).join(" ")}`);

				// if result contains products, take cpeName of first and extract product name
				// IF
				getCPEDetails(query, env).then((cveResponse: CPEResult) => {
						if (cveResponse.totalResults > 0) {
								const cpeName = cveResponse.products[0].cpe.cpeName;
								const product = cpeName.split(":")[4];
								return product;
						}
				});

		}

		// if no match, throw error
		throw new Error(`No match found for product name: ${productName}`);
}

// When filtering by cpeName the part, vendor, product, and version components
// are REQUIRED to contain values other than "*".
export function constructCpeName(buildInfo: BuildInfo, env: Env): string {

		const cpe_version = "2.3";
		const part = "a"; // application
		const vendor = findVendorName(buildInfo.manufacturerName, env);
		const product = findProductName(buildInfo.productName, vendor, env);
		const version = buildInfo.softwareVersion;

		return `cpe:${cpe_version}:${part}:${vendor}:${product}:${version}:*:*:*:*:*:*:*`;
}
