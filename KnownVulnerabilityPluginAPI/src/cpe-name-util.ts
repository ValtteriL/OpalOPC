import { getCPEDetails } from './cpe-api-util'
import { type CPEResult, type BuildInfo, type Env } from './types'

/**
* Convert a string to camel case
* @param str
* @returns
*/
function camelPad (str: string): string {
  return str
  // remove all non-word characters
    .replace(/\W/g, '')
  // Look for long acronyms and filter out the last letter
    .replace(/([A-Z]+)([A-Z][a-z])/g, ' $1 $2')
  // Look for lower-case letters followed by upper-case letters
    .replace(/([a-z\d])([A-Z])/g, '$1 $2')
  // Look for lower-case letters followed by numbers
    .replace(/([a-zA-Z])(\d)/g, '$1 $2')
    .replace(/^./, function (str) { return str.toUpperCase() })
  // Remove any white space left around the word
    .trim()
}

/**
 * Given a manufacturer name in buildinfo, find the CPE vendor name
 * @param manufacturerName
 * @returns
 */
async function findVendorName (manufacturerName: string, env: Env): Promise<string> {
  const padded = camelPad(manufacturerName)

  // split the padded string into words and print the list with one word less each time
  // the words should be removed from the end of the list
  // keep trying until we find a match or run out of words
  // if no match, return original string
  const splitPadded = padded.split(' ')
  for (let i = 0; i < splitPadded.length; i++) {
    const query = encodeURIComponent(splitPadded.slice(0, splitPadded.length - i).join(' '))

    // if result contains products, take cpeName of first and extract vendor
    // IF
    const cveResponse: CPEResult = await getCPEDetails(query, env)
    if (cveResponse.totalResults > 0) {
      const cpeName = cveResponse.products[0].cpe.cpeName
      const vendor = cpeName.split(':')[3]
      return vendor
    }
  }

  // if no match, throw error
  throw new Error(`No match found for manufacturer name: ${manufacturerName}`)
}

/**
 * Given a product name in buildinfo and correct CPE vendor, find the CPE product name
 * @param productName
 * @param vendor
 * @returns
 */
async function findProductName (productName: string, vendor: string, env: Env): Promise<string> {
  const padded = camelPad(productName)

  // split the padded string into words and print the list with one word less each time
  // the words should be removed from the end of the list
  // keep trying until we find a match or run out of words
  // if no match, return original string
  const splitPadded = padded.split(' ')
  for (let i = 0; i < splitPadded.length; i++) {
    const query = encodeURIComponent(`${vendor} ${splitPadded.slice(0, splitPadded.length - i).join(' ')}`)

    // if result contains products, take cpeName of first and extract product name
    // IF
    const cveResponse: CPEResult = await getCPEDetails(query, env)
    if (cveResponse.totalResults > 0) {
      const cpeName = cveResponse.products[0].cpe.cpeName
      const product = cpeName.split(':')[4]
      return product
    }
  }

  // if no match, throw error
  throw new Error(`No match found for product name: ${productName}`)
}

// When filtering by cpeName the part, vendor, product, and version components
// are REQUIRED to contain values other than "*".
export async function constructCpeName (buildInfo: BuildInfo, env: Env): Promise<string> {
  const cpeVersion = '2.3'
  const part = 'a' // application
  const vendor: string = await findVendorName(buildInfo.manufacturerName, env)
  const product: string = await findProductName(buildInfo.productName, vendor, env)
  const version = buildInfo.softwareVersion

  return `cpe:${cpeVersion}:${part}:${vendor}:${product}:${version}:*:*:*:*:*:*:*`
}
